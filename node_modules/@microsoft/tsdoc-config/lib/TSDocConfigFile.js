"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tsdoc_1 = require("@microsoft/tsdoc");
var fs = require("fs");
var resolve = require("resolve");
var path = require("path");
var Ajv = require("ajv");
var jju = require("jju");
var ajv = new Ajv({ verbose: true });
function initializeSchemaValidator() {
    var jsonSchemaPath = resolve.sync('@microsoft/tsdoc/schemas/tsdoc.schema.json', { basedir: __dirname });
    var jsonSchemaContent = fs.readFileSync(jsonSchemaPath).toString();
    var jsonSchema = jju.parse(jsonSchemaContent, { mode: 'cjson' });
    return ajv.compile(jsonSchema);
}
// Warning: AJV has a fairly strange API.  Each time this function is called, the function  object's
// properties get overwritten with the results of the latest validation.  Thus we need to be careful
// to read the properties before a subsequent call may occur.
var tsdocSchemaValidator = initializeSchemaValidator();
/**
 * Represents an individual `tsdoc.json` file.
 *
 * @public
 */
var TSDocConfigFile = /** @class */ (function () {
    function TSDocConfigFile() {
        this.log = new tsdoc_1.ParserMessageLog();
        this._extendsFiles = [];
        this._filePath = '';
        this._fileNotFound = true;
        this._hasErrors = false;
        this._fileMTime = 0;
        this._tsdocSchema = '';
        this._extendsPaths = [];
        this._tagDefinitions = [];
    }
    Object.defineProperty(TSDocConfigFile.prototype, "extendsFiles", {
        /**
         * Other config files that this file extends from.
         */
        get: function () {
            return this._extendsFiles;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TSDocConfigFile.prototype, "filePath", {
        /**
         * The full path of the file that was attempted to load.
         */
        get: function () {
            return this._filePath;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TSDocConfigFile.prototype, "fileNotFound", {
        /**
         * If true, then the TSDocConfigFile object contains an empty state, because the `tsdoc.json` file could
         * not be found by the loader.
         */
        get: function () {
            return this._fileNotFound;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TSDocConfigFile.prototype, "hasErrors", {
        /**
         * If true, then at least one error was encountered while loading this file or one of its "extends" files.
         *
         * @remarks
         * You can use {@link TSDocConfigFile.getErrorSummary} to report these errors.
         *
         * The individual messages can be retrieved from the {@link TSDocConfigFile.log} property of each `TSDocConfigFile`
         * object (including the {@link TSDocConfigFile.extendsFiles} tree).
         */
        get: function () {
            return this._hasErrors;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TSDocConfigFile.prototype, "tsdocSchema", {
        /**
         * The `$schema` field from the `tsdoc.json` file.
         */
        get: function () {
            return this._tsdocSchema;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TSDocConfigFile.prototype, "extendsPaths", {
        /**
         * The `extends` field from the `tsdoc.json` file.  For the parsed file contents,
         * use the `extendsFiles` property instead.
         */
        get: function () {
            return this._extendsPaths;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TSDocConfigFile.prototype, "tagDefinitions", {
        get: function () {
            return this._tagDefinitions;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * This can be used for cache eviction.  It returns true if the modification timestamp has changed for
     * any of the files that were read when loading this `TSDocConfigFile`, which indicates that the file should be
     * reloaded.  It does not consider cases where `TSDocConfigFile.fileNotFound` was `true`.
     *
     * @remarks
     * This can be used for cache eviction.  An example eviction strategy might be like this:
     *
     * - call `checkForModifiedFiles()` once per second, and reload the configuration if it returns true
     *
     * - otherwise, reload the configuration when it is more than 10 seconds old (to handle less common cases such
     *   as creation of a missing file, or creation of a file at an earlier location in the search path).
     */
    TSDocConfigFile.prototype.checkForModifiedFiles = function () {
        if (this._checkForModifiedFile()) {
            return true;
        }
        for (var _i = 0, _a = this.extendsFiles; _i < _a.length; _i++) {
            var extendsFile = _a[_i];
            if (extendsFile.checkForModifiedFiles()) {
                return true;
            }
        }
        return false;
    };
    /**
     * Checks the last modification time for `TSDocConfigFile.filePath` and returns `true` if it has changed
     * since the file was loaded.  If the file is missing, this returns `false`.  If the timestamp cannot be read,
     * then this returns `true`.
     */
    TSDocConfigFile.prototype._checkForModifiedFile = function () {
        if (this._fileNotFound || !this._filePath) {
            return false;
        }
        try {
            var mtimeMs = fs.statSync(this._filePath).mtimeMs;
            return mtimeMs !== this._fileMTime;
        }
        catch (error) {
            return true;
        }
    };
    TSDocConfigFile.prototype._reportError = function (parserMessageParameters) {
        this.log.addMessage(new tsdoc_1.ParserMessage(parserMessageParameters));
        this._hasErrors = true;
    };
    TSDocConfigFile.prototype._loadJsonFile = function () {
        var _a;
        var configJsonContent = fs.readFileSync(this._filePath).toString();
        this._fileMTime = fs.statSync(this._filePath).mtimeMs;
        this._fileNotFound = false;
        var configJson = jju.parse(configJsonContent, { mode: 'cjson' });
        if (configJson.$schema !== TSDocConfigFile.CURRENT_SCHEMA_URL) {
            this._reportError({
                messageId: "tsdoc-config-unsupported-schema" /* ConfigFileUnsupportedSchema */,
                messageText: "Unsupported JSON \"$schema\" value; expecting \"" + TSDocConfigFile.CURRENT_SCHEMA_URL + "\"",
                textRange: tsdoc_1.TextRange.empty
            });
            return;
        }
        var success = tsdocSchemaValidator(configJson);
        if (!success) {
            var description = ajv.errorsText(tsdocSchemaValidator.errors);
            this._reportError({
                messageId: "tsdoc-config-schema-error" /* ConfigFileSchemaError */,
                messageText: 'Error loading config file: ' + description,
                textRange: tsdoc_1.TextRange.empty
            });
            return;
        }
        this._tsdocSchema = configJson.$schema;
        if (configJson.extends) {
            (_a = this._extendsPaths).push.apply(_a, configJson.extends);
        }
        for (var _i = 0, _b = configJson.tagDefinitions || []; _i < _b.length; _i++) {
            var jsonTagDefinition = _b[_i];
            var syntaxKind = void 0;
            switch (jsonTagDefinition.syntaxKind) {
                case 'inline':
                    syntaxKind = tsdoc_1.TSDocTagSyntaxKind.InlineTag;
                    break;
                case 'block':
                    syntaxKind = tsdoc_1.TSDocTagSyntaxKind.BlockTag;
                    break;
                case 'modifier':
                    syntaxKind = tsdoc_1.TSDocTagSyntaxKind.ModifierTag;
                    break;
                default:
                    // The JSON schema should have caught this error
                    throw new Error('Unexpected tag kind');
            }
            this._tagDefinitions.push(new tsdoc_1.TSDocTagDefinition({
                tagName: jsonTagDefinition.tagName,
                syntaxKind: syntaxKind,
                allowMultiple: jsonTagDefinition.allowMultiple
            }));
        }
    };
    TSDocConfigFile.prototype._loadWithExtends = function (configFilePath, referencingConfigFile, alreadyVisitedPaths) {
        if (!configFilePath) {
            this._reportError({
                messageId: "tsdoc-config-file-not-found" /* ConfigFileNotFound */,
                messageText: 'File not found',
                textRange: tsdoc_1.TextRange.empty
            });
            return;
        }
        this._filePath = path.resolve(configFilePath);
        if (!fs.existsSync(this._filePath)) {
            this._reportError({
                messageId: "tsdoc-config-file-not-found" /* ConfigFileNotFound */,
                messageText: 'File not found',
                textRange: tsdoc_1.TextRange.empty
            });
            return;
        }
        var hashKey = fs.realpathSync(this._filePath);
        if (referencingConfigFile && alreadyVisitedPaths.has(hashKey)) {
            this._reportError({
                messageId: "tsdoc-config-cyclic-extends" /* ConfigFileCyclicExtends */,
                messageText: "Circular reference encountered for \"extends\" field of \"" + referencingConfigFile.filePath + "\"",
                textRange: tsdoc_1.TextRange.empty
            });
            return;
        }
        alreadyVisitedPaths.add(hashKey);
        this._loadJsonFile();
        var configFileFolder = path.dirname(this.filePath);
        for (var _i = 0, _a = this.extendsPaths; _i < _a.length; _i++) {
            var extendsField = _a[_i];
            var resolvedExtendsPath = resolve.sync(extendsField, { basedir: configFileFolder });
            var baseConfigFile = new TSDocConfigFile();
            baseConfigFile._loadWithExtends(resolvedExtendsPath, this, alreadyVisitedPaths);
            if (baseConfigFile.fileNotFound) {
                this._reportError({
                    messageId: "tsdoc-config-unresolved-extends" /* ConfigFileUnresolvedExtends */,
                    messageText: "Unable to resolve \"extends\" reference to \"" + extendsField + "\"",
                    textRange: tsdoc_1.TextRange.empty
                });
            }
            this._extendsFiles.push(baseConfigFile);
            if (baseConfigFile.hasErrors) {
                this._hasErrors = true;
            }
        }
    };
    /**
     * For the given folder, look for the relevant tsdoc.json file (if any), and return its path.
     *
     * @param folderPath - the path to a folder where the search should start
     * @returns the (possibly relative) path to tsdoc.json, or an empty string if not found
     */
    TSDocConfigFile.findConfigPathForFolder = function (folderPath) {
        if (folderPath) {
            var foundFolder = folderPath;
            for (;;) {
                var tsconfigJsonPath = path.join(foundFolder, 'tsconfig.json');
                if (fs.existsSync(tsconfigJsonPath)) {
                    // Stop when we reach a folder containing tsconfig.json
                    return path.join(foundFolder, TSDocConfigFile.FILENAME);
                }
                var packageJsonPath = path.join(foundFolder, 'package.json');
                if (fs.existsSync(packageJsonPath)) {
                    // Stop when we reach a folder containing package.json; this avoids crawling out of the current package
                    return path.join(foundFolder, TSDocConfigFile.FILENAME);
                }
                var previousFolder = foundFolder;
                foundFolder = path.dirname(foundFolder);
                if (!foundFolder || foundFolder === previousFolder) {
                    // Give up if we reach the filesystem root directory
                    break;
                }
            }
        }
        return '';
    };
    /**
     * Calls `TSDocConfigFile.findConfigPathForFolder()` to find the relevant tsdoc.json config file, if one exists.
     * Then calls `TSDocConfigFile.findConfigPathForFolder()` to return the loaded result.
     * @param folderPath - the path to a folder where the search should start
     */
    TSDocConfigFile.loadForFolder = function (folderPath) {
        var rootConfigPath = TSDocConfigFile.findConfigPathForFolder(folderPath);
        return TSDocConfigFile.loadFile(rootConfigPath);
    };
    /**
     * Loads the specified tsdoc.json and any base files that it refers to using the "extends" option.
     * @param tsdocJsonFilePath - the path to the tsdoc.json config file
     */
    TSDocConfigFile.loadFile = function (tsdocJsonFilePath) {
        var configFile = new TSDocConfigFile();
        var alreadyVisitedPaths = new Set();
        configFile._loadWithExtends(tsdocJsonFilePath, undefined, alreadyVisitedPaths);
        return configFile;
    };
    /**
     * Returns a report of any errors that occurred while attempting to load this file or any files
     * referenced via the "extends" field.
     *
     * @remarks
     * Use {@link TSDocConfigFile.hasErrors} to determine whether any errors occurred.
     */
    TSDocConfigFile.prototype.getErrorSummary = function () {
        if (!this._hasErrors) {
            return 'No errors.';
        }
        var result = "Errors encountered for " + this.filePath + ":\n";
        for (var _i = 0, _a = this.log.messages; _i < _a.length; _i++) {
            var message = _a[_i];
            result += "  " + message.text + "\n";
        }
        for (var _b = 0, _c = this.extendsFiles; _b < _c.length; _b++) {
            var extendsFile = _c[_b];
            if (extendsFile.hasErrors) {
                result += extendsFile.getErrorSummary();
            }
        }
        return result;
    };
    /**
     * Applies the settings from this config file to a TSDoc parser configuration.
     * Any `extendsFile` settings will also applied.
     */
    TSDocConfigFile.prototype.configureParser = function (configuration) {
        // First apply the base config files
        for (var _i = 0, _a = this.extendsFiles; _i < _a.length; _i++) {
            var extendsFile = _a[_i];
            extendsFile.configureParser(configuration);
        }
        // Then apply this one
        for (var _b = 0, _c = this.tagDefinitions; _b < _c.length; _b++) {
            var tagDefinition = _c[_b];
            configuration.addTagDefinition(tagDefinition);
        }
    };
    TSDocConfigFile.FILENAME = 'tsdoc.json';
    TSDocConfigFile.CURRENT_SCHEMA_URL = 'https://developer.microsoft.com/json-schemas/tsdoc/v0/tsdoc.schema.json';
    return TSDocConfigFile;
}());
exports.TSDocConfigFile = TSDocConfigFile;
//# sourceMappingURL=TSDocConfigFile.js.map