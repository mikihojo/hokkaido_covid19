"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var tsdoc_1 = require("@microsoft/tsdoc");
var Debug_1 = require("./Debug");
var ConfigCache_1 = require("./ConfigCache");
var tsdocMessageIds = {};
var defaultTSDocConfiguration = new tsdoc_1.TSDocConfiguration();
defaultTSDocConfiguration.allTsdocMessageIds.forEach(function (messageId) {
    tsdocMessageIds[messageId] = messageId + ": {{unformattedText}}";
});
var plugin = {
    rules: {
        // NOTE: The actual ESLint rule name will be "tsdoc/syntax".  It is calculated by deleting "eslint-plugin-"
        // from the NPM package name, and then appending this string.
        "syntax": {
            meta: {
                messages: __assign({ "error-loading-config-file": "Error loading TSDoc config file:\n{{details}}", "error-applying-config": "Error applying TSDoc configuration: {{details}}" }, tsdocMessageIds),
                type: "problem",
                docs: {
                    description: "Validates that TypeScript documentation comments conform to the TSDoc standard",
                    category: "Stylistic Issues",
                    // This package is experimental
                    recommended: false,
                    url: "https://github.com/microsoft/tsdoc/blob/master/eslint-plugin/README.md"
                }
            },
            create: function (context) {
                var sourceFilePath = context.getFilename();
                Debug_1.Debug.log("Linting: \"" + sourceFilePath + "\"");
                var tsdocConfiguration = new tsdoc_1.TSDocConfiguration();
                try {
                    var tsdocConfigFile = ConfigCache_1.ConfigCache.getForSourceFile(sourceFilePath);
                    if (!tsdocConfigFile.fileNotFound) {
                        if (tsdocConfigFile.hasErrors) {
                            context.report({
                                loc: { line: 1, column: 1 },
                                messageId: "error-loading-config-file",
                                data: {
                                    details: tsdocConfigFile.getErrorSummary()
                                }
                            });
                        }
                        try {
                            tsdocConfigFile.configureParser(tsdocConfiguration);
                        }
                        catch (e) {
                            context.report({
                                loc: { line: 1, column: 1 },
                                messageId: "error-applying-config",
                                data: {
                                    details: e.message
                                }
                            });
                        }
                    }
                }
                catch (e) {
                    context.report({
                        loc: { line: 1, column: 1 },
                        messageId: "error-loading-config-file",
                        data: {
                            details: "Unexpected exception: " + e.message
                        }
                    });
                }
                var tsdocParser = new tsdoc_1.TSDocParser(tsdocConfiguration);
                var sourceCode = context.getSourceCode();
                var checkCommentBlocks = function (node) {
                    for (var _i = 0, _a = sourceCode.getAllComments(); _i < _a.length; _i++) {
                        var comment = _a[_i];
                        if (comment.type !== "Block") {
                            continue;
                        }
                        if (!comment.range) {
                            continue;
                        }
                        var textRange = tsdoc_1.TextRange.fromStringRange(sourceCode.text, comment.range[0], comment.range[1]);
                        // Smallest comment is "/***/"
                        if (textRange.length < 5) {
                            continue;
                        }
                        // Make sure it starts with "/**"
                        if (textRange.buffer[textRange.pos + 2] !== '*') {
                            continue;
                        }
                        var parserContext = tsdocParser.parseRange(textRange);
                        for (var _b = 0, _c = parserContext.log.messages; _b < _c.length; _b++) {
                            var message = _c[_b];
                            context.report({
                                loc: {
                                    start: sourceCode.getLocFromIndex(message.textRange.pos),
                                    end: sourceCode.getLocFromIndex(message.textRange.end)
                                },
                                messageId: message.messageId,
                                data: {
                                    unformattedText: message.unformattedText
                                }
                            });
                        }
                    }
                };
                return {
                    Program: checkCommentBlocks
                };
            }
        }
    }
};
module.exports = plugin;
